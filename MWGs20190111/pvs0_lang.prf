(pvs0_lang
 (terminating?_TCC1 0
  (terminating?_TCC1-1 nil 3746202367 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (deterministic 0
  (deterministic-1 nil 3665322795
   ("" (skeep*)
    (("" (expand "semantic_rel")
      (("" (expand "semantic_rel")
        (("" (lemma "deterministic_expr")
          (("" (inst?) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((semantic_rel const-decl "bool" pvs0_lang nil)
    (list type-decl nil list_adt nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (deterministic_expr formula-decl nil pvs0_expr nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (eval_pvs0_ge_n 0
  (eval_pvs0_ge_n-1 nil 3665418053
   ("" (skeep*)
    (("" (expand "eval" :assert? nil)
      (("" (lemma "eval_expr_ge_n")
        (("" (beta) (("" (inst?) nil nil)) nil)) nil))
      nil))
    nil)
   ((eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          i > 0 AND
           (FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env))}"
     pvs0_lang nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}"
     pvs0_lang nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (list type-decl nil list_adt nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (eval_expr_ge_n formula-decl nil pvs0_expr nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (semantic_rel_eval 0
  (semantic_rel_eval-1 nil 3665331731
   ("" (skeep*)
    (("" (expand "semantic_rel")
      (("" (expand "semantic_rel")
        (("" (expand "eval")
          (("" (lemma "semantic_rel_eval_expr")
            (("" (inst?) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((semantic_rel const-decl "bool" pvs0_lang nil)
    (semantic_rel_eval_expr formula-decl nil pvs0_expr nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}"
     pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          i > 0 AND
           (FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env))}"
     pvs0_lang nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (eval_terminates 0
  (eval_terminates-1 nil 3665340436
   ("" (skeep)
    (("" (expand "eval_termination")
      (("" (expand "terminating?")
        (("" (expand "terminates")
          (("" (lemma "eval_expr_terminates") (("" (inst?) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((eval_termination const-decl "bool" pvs0_lang nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (eval_expr_terminates formula-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (terminating? const-decl "bool" pvs0_lang nil))
   shostak))
 (terminating_determined_all 0
  (terminating_determined_all-1 nil 3666615570
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (skeep)
          (("1" (expand "terminating?")
            (("1" (expand "determined?")
              (("1" (expand "terminates_expr")
                (("1" (expand "semantic_rel")
                  (("1" (inst? -1) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "determined?")
          (("2" (expand "terminating?")
            (("2" (expand "terminates_expr")
              (("2" (skeep)
                (("2" (expand "semantic_rel") (("2" (inst? -) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((determined? const-decl "bool" pvs0_lang nil)
    (semantic_rel const-decl "bool" pvs0_lang nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (terminates_expr const-decl "bool" pvs0_expr nil)
    (terminating? const-decl "bool" pvs0_lang nil))
   nil))
 (mu_nonempty 0
  (mu_nonempty-1 nil 3665341553
   ("" (skeep :preds? t)
    (("" (expand "determined?")
      (("" (beta)
        (("" (expand "nonempty?")
          (("" (expand "empty?")
            (("" (skeep -1)
              (("" (expand "semantic_rel")
                (("" (lemma "semantic_rel_eval_expr")
                  (("" (inst?)
                    (("" (assert)
                      (("" (skeep)
                        (("" (inst -4 "n")
                          (("" (expand "member")
                            (("" (expand "eval")
                              (("" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((determined? const-decl "bool" pvs0_lang nil)
    (nonempty? const-decl "bool" sets nil)
    (semantic_rel_eval_expr formula-decl nil pvs0_expr nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}"
     pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          i > 0 AND
           (FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env))}"
     pvs0_lang nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (member const-decl "bool" sets nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (semantic_rel const-decl "bool" pvs0_lang nil)
    (empty? const-decl "bool" sets nil))
   shostak))
 (mu_TCC1 0
  (mu_TCC1-1 nil 3665342319
   ("" (use "mu_nonempty")
    (("" (skeep) (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)
   ((determined? const-decl "bool" pvs0_lang nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (mu_nonempty formula-decl nil pvs0_lang nil))
   nil))
 (mu_TCC2 0
  (mu_TCC2-1 nil 3665342319
   ("" (skeep)
    (("" (replace -1 :hide? t)
      (("" (invoke (typepred "%1") (! 1 1))
        (("1" (lemma "eval_expr_gt_0")
          (("1" (assert)
            (("1"
              (name "n_"
                    "min[nat]({n: nat | some?(eval(pvs0)(n)(val))})")
              (("1" (replace -1 :hide? t)
                (("1" (expand "eval" -2)
                  (("1" (inst? -1 :where -2) (("1" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (hide-all-but 1)
                (("2" (use "mu_nonempty") (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (use "mu_nonempty") (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((eval_expr_gt_0 formula-decl nil pvs0_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (mu_nonempty formula-decl nil pvs0_lang nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          i > 0 AND
           (FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env))}"
     pvs0_lang nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}"
     pvs0_lang nil)
    (determined? const-decl "bool" pvs0_lang nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (mu_terminates 0
  (mu_terminates-1 nil 3665342327
   ("" (skeep)
    (("" (skoletin* 1)
      (("" (expand "mu")
        (("" (invoke (typepred "%1") (! -2 2))
          (("1" (replaces -4 :dir rl) (("1" (assert) nil nil)) nil)
           ("2" (lemma "mu_nonempty")
            (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (list type-decl nil list_adt nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (determined? const-decl "bool" pvs0_lang nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (mu const-decl "posnat" pvs0_lang nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (mu_nonempty formula-decl nil pvs0_lang nil))
   shostak))
 (mu_min 0
  (mu_min-1 nil 3665582367
   ("" (skeep)
    (("" (expand "mu")
      (("" (typepred "min({n: nat | some?(eval(pvs0)(n)(val))})")
        (("1" (inst -2 "n") (("1" (assert) nil nil)) nil)
         ("2" (use "mu_nonempty") (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((mu const-decl "posnat" pvs0_lang nil)
    (mu_nonempty formula-decl nil pvs0_lang nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (Maybe type-decl nil Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (list type-decl nil list_adt nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}"
         min_nat nil)
    (determined? const-decl "bool" pvs0_lang nil))
   shostak))
 (mu_eval_TCC1 0
  (mu_eval_TCC1-1 nil 3665342771 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (list type-decl nil list_adt nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (determined? const-decl "bool" pvs0_lang nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (semantic_rel const-decl "bool" pvs0_lang nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (mu const-decl "posnat" pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          i > 0 AND
           (FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env))}"
     pvs0_lang nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}"
     pvs0_lang nil))
   nil))
 (eval_semantic 0
  (eval_semantic-1 nil 3665349526
   ("" (skeep*)
    (("" (lemma "eval_expr_semantic_rel")
      (("" (assert)
        (("" (expand "semantic_rel")
          (("" (inst?)
            (("" (inst -1 "mu(pvs0)(arg)")
              (("" (assert)
                (("" (expand "eval") (("" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((eval_expr_semantic_rel formula-decl nil pvs0_expr nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (semantic_rel const-decl "bool" pvs0_lang nil)
    (mu const-decl "posnat" pvs0_lang nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (determined? const-decl "bool" pvs0_lang nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          i > 0 AND
           (FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env))}"
     pvs0_lang nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}"
     pvs0_lang nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (mu_eval_correct 0
  (mu_eval_correct-1 nil 3665342815
   ("" (skeep*)
    (("" (split 1)
      (("1" (flatten)
        (("1" (use "deterministic")
          (("1" (assert)
            (("1" (hide 2)
              (("1" (use "mu_terminates")
                (("1" (assert)
                  (("1" (expand "mu_eval")
                    (("1" (use "eval_semantic")
                      (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (replace -1 :hide? t)
          (("2" (expand "semantic_rel")
            (("2" (expand "mu_eval")
              (("2" (expand "eval")
                (("2" (use "eval_expr_semantic_rel")
                  (("2" (assert)
                    (("2" (assert)
                      (("2" (hide 2)
                        (("2" (use " mu_terminates")
                          (("2" (assert)
                            (("2" (expand "eval")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((deterministic formula-decl nil pvs0_lang nil)
    (determined? const-decl "bool" pvs0_lang nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (mu_eval const-decl "Val" pvs0_lang nil)
    (eval_semantic formula-decl nil pvs0_lang nil)
    (mu_terminates formula-decl nil pvs0_lang nil)
    (eval_expr_semantic_rel formula-decl nil pvs0_expr nil)
    (mu const-decl "posnat" pvs0_lang nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_expr nil)
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          i > 0 AND
           (FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env))}"
     pvs0_lang nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}"
     pvs0_lang nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (semantic_rel const-decl "bool" pvs0_lang nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (Delta_undetermined 0
  (Delta_undetermined-1 nil 3666649173
   ("" (skeep*)
    (("" (lemma "mu_terminates")
      (("" (inst? -1)
        (("" (inst -1 "val")
          (("" (skoletin* -1)
            (("" (expand "eval")
              (("" (expand "Delta" -2)
                (("" (expand "nth")
                  (("" (expand "eval_expr")
                    (("" (case-replace "mun=0")
                      (("1" (assert) nil nil)
                       ("2" (assert)
                        (("2" (expand "eval_expr" -2 1)
                          (("2" (expand "eval_expr" -2 2)
                            (("2" (lemma "mu_min")
                              (("2"
                                (inst
                                 -1
                                 "Delta(false_val, eval_op1, eval_op2)"
                                 "val"
                                 "mun-1")
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand "eval" 1)
                                    (("2"
                                      (expand "Delta" 1)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "length")
                                          (("2"
                                            (expand "length")
                                            (("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((mu_terminates formula-decl nil pvs0_lang nil)
    (val skolem-const-decl "Val" pvs0_lang nil)
    (eval_op2 skolem-const-decl "EvalOp2[Val]" pvs0_lang nil)
    (eval_op1 skolem-const-decl "EvalOp1[Val]" pvs0_lang nil)
    (false_val skolem-const-decl "Val" pvs0_lang nil)
    (determined? const-decl "bool" pvs0_lang nil)
    (nth def-decl "T" list_props nil)
    (mu_min formula-decl nil pvs0_lang nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          i > 0 AND
           (FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env))}"
     pvs0_lang nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}"
     pvs0_lang nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_expr nil)
    (eval const-decl "Maybe[Val]" pvs0_lang nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (mu const-decl "posnat" pvs0_lang nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Delta const-decl "PVS0" pvs0_lang nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (Delta_non_terminating 0
  (Delta_non_terminating-1 nil 3665579603
   ("" (skeep)
    (("" (lemma "terminating_determined_all")
      (("" (inst?)
        (("" (assert)
          (("" (lemma "Delta_undetermined")
            (("" (inst? -1)
              (("" (inst -1 "false_val")
                (("" (inst -1 "false_val") nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((terminating_determined_all formula-decl nil pvs0_lang nil)
    (Delta_undetermined formula-decl nil pvs0_lang nil)
    (Delta const-decl "PVS0" pvs0_lang nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil))
   shostak))
 (pvs0_not_in_pvs 0
  (pvs0_not_in_pvs-2 nil 3665708529
   (""
    (inst 1
     "Delta(choose({v:Val|TRUE}),(:LAMBDA(v:Val):v:),(:LAMBDA(v1,v2:Val):v1:))")
    (("1" (skeep)
      (("1" (lemma "Delta_non_terminating")
        (("1" (inst?)
          (("1" (expand "terminating?")
            (("1" (expand "terminates_expr")
              (("1" (skeep)
                (("1" (inst -1 "env")
                  (("1" (inst 1 "f(env)")
                    (("1" (expand "semantic_rel")
                      (("1" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide -1) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (grind) nil nil))
    nil)
   ((terminates_expr const-decl "bool" pvs0_expr nil)
    (semantic_rel const-decl "bool" pvs0_lang nil)
    (terminating? const-decl "bool" pvs0_lang nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (Delta_non_terminating formula-decl nil pvs0_lang nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (choose const-decl "(p)" sets nil)
    (Delta const-decl "PVS0" pvs0_lang nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (offset_rec_TCC1 0
  (offset_rec_TCC1-1 nil 3746289874 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt
     nil))
   nil))
 (offset_rec_TCC2 0
  (offset_rec_TCC2-1 nil 3746289874 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt
     nil))
   nil))
 (offset_rec_TCC3 0
  (offset_rec_TCC3-1 nil 3746289874 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt
     nil))
   nil))
 (offset_rec_TCC4 0
  (offset_rec_TCC4-1 nil 3746289874 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt
     nil))
   nil))
 (offset_rec_TCC5 0
  (offset_rec_TCC5-1 nil 3746289874 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt
     nil))
   nil))
 (offset_rec_TCC6 0
  (offset_rec_TCC6-1 nil 3746289874 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt
     nil))
   nil))
 (offset_rec_TCC7 0
  (offset_rec_TCC7-1 nil 3746289874 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[PVS0Expr])" PVS0Expr_adt
     nil))
   nil))
 (offset_composition 0
  (offset_composition-1 nil 3746290291
   ("" (induct "expr")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PVS0Expr_induction formula-decl nil PVS0Expr_adt nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (offset_rec def-decl "PVS0Expr" pvs0_lang nil)
    (O const-decl "T3" function_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (offset_composition2 0
  (offset_composition2-1 nil 3746290400
   ("" (lemma "offset_composition")
    (("" (skeep) (("" (decompose-equality) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((Val formal-nonempty-type-decl nil pvs0_lang nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (offset_rec def-decl "PVS0Expr" pvs0_lang nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (O const-decl "T3" function_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (offset_composition formula-decl nil pvs0_lang nil))
   nil))
 (add_rec_list_aux_TCC1 0
  (add_rec_list_aux_TCC1-1 nil 3746290545 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (append def-decl "list[T]" list_props nil))
   nil))
 (add_rec_list_aux 0
  (add_rec_list_aux-2 nil 3746290873
   ("" (measure-induct+ "lex2(k,sizepvs0(expr))" ("expr" "k"))
    (("1" (skeep*)
      (("1" (expand "eval_expr" 1 1)
        (("1" (lift-if)
          (("1" (prop)
            (("1" (grind) nil nil) ("2" (grind) nil nil)
             ("3" (grind) nil nil)
             ("4" (beta)
              (("4" (expand "offset_rec" 1 2)
                (("4" (assert)
                  (("4" (lift-if)
                    (("4" (prop)
                      (("1" (expand "eval_expr" 1 2)
                        (("1" (assert)
                          (("1" (lift-if)
                            (("1" (prop)
                              (("1"
                                (inst -4 "get_arg(x!1)" "x!2")
                                (("1"
                                  (inst
                                   -4
                                   "false_val"
                                   "lexpr1"
                                   "lexpr2")
                                  (("1"
                                    (prop)
                                    (("1"
                                      (inst?)
                                      (("1"
                                        (assert)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (inst -3 "get_arg(x!1)" "x!2")
                                (("2"
                                  (inst
                                   -3
                                   "false_val"
                                   "lexpr1"
                                   "lexpr2")
                                  (("2"
                                    (prop)
                                    (("1"
                                      (inst?)
                                      (("1" (assert) nil nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "eval_expr" 2)
                        (("2" (assert)
                          (("2" (lift-if)
                            (("2" (prop)
                              (("2"
                                (inst -3 "get_arg(x!1)" "x!2")
                                (("2"
                                  (inst?)
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (prop)
                                      (("1"
                                        (inst?)
                                        (("1" (assert) nil nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("5" (assert)
              (("5" (inst-cp -2 "get_arg1(x!1)" "x!2")
                (("5" (inst -2 "get_arg2(x!1)" "x!2")
                  (("5" (inst?)
                    (("5" (inst?)
                      (("5" (inst?)
                        (("5" (inst?)
                          (("5" (split)
                            (("1" (split)
                              (("1"
                                (inst?)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (expand "offset_rec" 1 2)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "eval_expr" 1 5)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("6" (beta)
              (("6" (inst-cp -2 "get_cond(x!1)" "x!2")
                (("6" (inst? -3)
                  (("6" (inst? -3)
                    (("6" (prop)
                      (("1" (inst?)
                        (("1"
                          (case "false_val /=
                                                        val(eval_expr(f1, f2, false_val, lexpr1)
                                                                     (x!2, get_cond(x!1), i))")
                          (("1" (inst -4 "get_if(x!1)" "x!2")
                            (("1" (inst?)
                              (("1"
                                (inst?)
                                (("1"
                                  (prop)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "offset_rec" 2 2)
                                        (("1"
                                          (expand "eval_expr" 2 3)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (inst -3 "get_else(x!1)" "x!2")
                            (("2" (inst?)
                              (("2"
                                (inst?)
                                (("2"
                                  (prop)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "offset_rec" 1 2)
                                        (("1"
                                          (expand "eval_expr" 1 3)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (assert)
                            (("3" (expand "offset_rec" 2 2)
                              (("3"
                                (expand "eval_expr" 2)
                                (("3" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("7" (beta)
              (("7" (inst-cp -1 "get_arg(x!1)" "x!2")
                (("1"
                  (inst -1 " nth(lexpr1, get_from_list(x!1))" "x!2-1")
                  (("1" (inst?)
                    (("1" (inst?)
                      (("1" (prop)
                        (("1" (inst?)
                          (("1" (inst?)
                            (("1" (inst?)
                              (("1"
                                (prop)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (expand "offset_rec" 2 2)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "eval_expr" 2 4)
                                        (("1"
                                          (rewrite "length_append")
                                          (("1"
                                            (rewrite "map_length")
                                            (("1"
                                              (rewrite "nth_append")
                                              (("1"
                                                (rewrite "map_nth_rw")
                                                (("1"
                                                  (replace -1 :dir rl)
                                                  (("1"
                                                    (replace
                                                     -2
                                                     :dir
                                                     rl)
                                                    (("1"
                                                      (lift-if)
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (lift-if)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (rewrite "map_length")
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (inst?)
                              (("2"
                                (inst?)
                                (("2"
                                  (prop)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (expand "offset_rec" 3 2)
                                      (("1"
                                        (expand "eval_expr" 3)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (assert) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil)
                   ("3" (assert)
                    (("3" (inst?)
                      (("3" (inst?)
                        (("3" (prop)
                          (("1" (inst?)
                            (("1" (expand "offset_rec" 3 2)
                              (("1"
                                (expand "eval_expr" 3 2)
                                (("1"
                                  (rewrite "length_append")
                                  (("1"
                                    (rewrite "map_length")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (replace -1 :dir rl)
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("4" (assert) nil nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)
     ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (< const-decl "bool" reals nil)
    (get_from_list adt-accessor-decl "[(rec?) -> nat]" PVS0Expr_adt
     nil)
    (lexpr1 skolem-const-decl "lPVS0Expr[Val]" pvs0_lang nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (x!2 skolem-const-decl "nat" pvs0_lang nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (f1 skolem-const-decl "EvalOp1[Val]" pvs0_lang nil)
    (f2 skolem-const-decl "EvalOp2[Val]" pvs0_lang nil)
    (false_val skolem-const-decl "Val" pvs0_lang nil)
    (i skolem-const-decl "Val" pvs0_lang nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nth_append formula-decl nil more_list_props "structures/")
    (map_nth_rw formula-decl nil more_map_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (map_length formula-decl nil more_map_props nil)
    (/= const-decl "boolean" notequal nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (get_if adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil)
    (get_else adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt
     nil)
    (get_cond adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt
     nil)
    (x!1 skolem-const-decl "PVS0Expr[Val]" pvs0_lang nil)
    (ite? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (get_arg2 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt
     nil)
    (eval_op2 const-decl "Val" pvs0_expr nil)
    (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (get_arg1 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt
     nil)
    (eval_op1 const-decl "Val" pvs0_expr nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (get_arg shared-adt-accessor-decl
     "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt
     nil)
    (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          i > 0 AND
           (FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env))}"
     pvs0_lang nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}"
     pvs0_lang nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_expr nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Maybe type-decl nil Maybe "structures/")
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (append def-decl "list[T]" list_props nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (offset_rec def-decl "PVS0Expr" pvs0_lang nil)
    (length def-decl "nat" list_props nil)
    (well_founded_le formula-decl nil ordinals nil)
    (< def-decl "bool" ordinals nil)
    (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   nil)
  (add_rec_list_aux-1 nil 3746290558
   ("" (measure-induct+ "lex2(k,sizepvs0(expr))" ("expr" "k"))
    (("1" (skeep*)
      (("1" (expand "eval_expr" 1 1)
        (("1" (lift-if)
          (("1" (prop)
            (("1" (grind) nil) ("2" (grind) nil) ("3" (grind) nil)
             ("4" (beta)
              (("4" (expand "offset_rec" 1 2)
                (("4" (assert)
                  (("4" (lift-if)
                    (("4" (prop)
                      (("1" (expand "eval_expr" 1 2)
                        (("1" (assert)
                          (("1" (lift-if)
                            (("1" (prop)
                              (("1"
                                (inst -5 "get_arg(x!1)" "x!2")
                                (("1"
                                  (inst
                                   -5
                                   "false_val"
                                   "lexpr1"
                                   "lexpr2")
                                  (("1"
                                    (prop)
                                    (("1" (inst?) (("1" (assert) nil)))
                                     ("2" (grind) nil)))))))
                               ("2"
                                (inst -4 "get_arg(x!1)" "x!2")
                                (("2"
                                  (inst
                                   -4
                                   "false_val"
                                   "lexpr1"
                                   "lexpr2")
                                  (("2"
                                    (prop)
                                    (("1" (inst?) (("1" (assert) nil)))
                                     ("2" (grind) nil)))))))))))))))
                       ("2" (expand "eval_expr" 2)
                        (("2" (assert)
                          (("2" (lift-if)
                            (("2" (prop)
                              (("2"
                                (inst -3 "get_arg(x!1)" "x!2")
                                (("2"
                                  (inst?)
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (prop)
                                      (("1"
                                        (inst?)
                                        (("1" (assert) nil)))
                                       ("2"
                                        (grind)
                                        nil)))))))))))))))))
                       ("3" (expand "eval_expr" 2)
                        (("3" (lift-if)
                          (("3" (split)
                            (("1" (flatten)
                              (("1"
                                (inst -3 "get_arg(x!1)" "x!2")
                                (("1"
                                  (inst?)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (split -3)
                                      (("1"
                                        (inst?)
                                        (("1" (assert) nil)))
                                       ("2" (grind) nil)))))))))))
                             ("2" (propax) nil)))))))))))))))))
             ("5" (beta)
              (("5" (inst-cp -2 "get_arg1(x!1)" "x!2")
                (("5" (inst -2 "get_arg2(x!1)" "x!2")
                  (("5" (inst?)
                    (("5" (inst?)
                      (("5" (inst?)
                        (("5" (inst?)
                          (("5" (split)
                            (("1" (split)
                              (("1"
                                (inst?)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (expand "offset_rec" 1 2)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "eval_expr" 1 5)
                                        (("1" (grind) nil)))))))))))
                               ("2" (grind) nil)))
                             ("2" (grind) nil)))))))))))))))))
             ("6" (beta)
              (("6" (inst-cp -2 "get_cond(x!1)" "x!2")
                (("6" (inst? -3)
                  (("6" (inst? -3)
                    (("6" (prop)
                      (("1" (inst?)
                        (("1"
                          (case "false_val /=
                              val(eval_expr(f1, f2, false_val, lexpr1)
                                           (x!2, get_cond(x!1), i))")
                          (("1" (inst -4 "get_if(x!1)" "x!2")
                            (("1" (inst?)
                              (("1"
                                (inst?)
                                (("1"
                                  (prop)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "offset_rec" 2 2)
                                        (("1"
                                          (expand "eval_expr" 2 3)
                                          (("1" (grind) nil)))))))))
                                   ("2" (grind) nil)))))))))
                           ("2" (inst -3 "get_else(x!1)" "x!2")
                            (("2" (inst?)
                              (("2"
                                (inst?)
                                (("2"
                                  (prop)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "offset_rec" 1 2)
                                        (("1"
                                          (expand "eval_expr" 1 3)
                                          (("1" (grind) nil)))))))))
                                   ("2" (grind) nil)))))))))
                           ("3" (assert)
                            (("3" (expand "offset_rec" 2 2)
                              (("3"
                                (expand "eval_expr" 2)
                                (("3" (propax) nil)))))))))))
                       ("2" (grind) nil)))))))))))
             ("7" (beta)
              (("7" (inst-cp -1 "get_arg(x!1)" "x!2")
                (("1"
                  (inst -1 " nth(lexpr1, get_from_list(x!1))" "x!2-1")
                  (("1" (inst?)
                    (("1" (inst?)
                      (("1" (prop)
                        (("1" (inst?)
                          (("1" (inst?)
                            (("1" (inst?)
                              (("1"
                                (prop)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (expand "offset_rec" 2 2)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "eval_expr" 2 4)
                                        (("1"
                                          (rewrite "length_append")
                                          (("1"
                                            (rewrite "map_length")
                                            (("1"
                                              (rewrite "nth_append")
                                              (("1"
                                                (rewrite "map_nth_rw")
                                                (("1"
                                                  (replace -1 :dir rl)
                                                  (("1"
                                                    (replace
                                                     -2
                                                     :dir
                                                     rl)
                                                    (("1"
                                                      (lift-if)
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (lift-if)
                                                          (("1"
                                                            (assert)
                                                            nil)))))))))))))
                                               ("2"
                                                (rewrite "map_length")
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (grind)
                                                    nil)))))))))))))))))))
                                 ("2" (grind) nil)))))))
                           ("2" (assert)
                            (("2" (inst?)
                              (("2"
                                (inst?)
                                (("2"
                                  (prop)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (expand "offset_rec" 3 2)
                                      (("1"
                                        (expand "eval_expr" 3)
                                        (("1" (assert) nil)))))))
                                   ("2" (grind) nil)))))))))
                           ("3" (assert) nil)))
                         ("2" (grind) nil)))))))
                   ("2" (assert) nil)
                   ("3" (assert)
                    (("3" (inst?)
                      (("3" (inst?)
                        (("3" (prop)
                          (("1" (inst?)
                            (("1" (expand "offset_rec" 3 2)
                              (("1"
                                (expand "eval_expr" 3 2)
                                (("1"
                                  (rewrite "length_append")
                                  (("1"
                                    (rewrite "map_length")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (replace -1 :dir rl)
                                        (("1"
                                          (propax)
                                          nil)))))))))))))))
                           ("2" (grind) nil)))))))))
                   ("4" (assert) nil)))
                 ("2" (assert) nil)))))))))))))
     ("2" (grind) nil) ("3" (grind) nil) ("4" (grind) nil)
     ("5" (grind) nil) ("6" (grind) nil) ("7" (grind) nil))
    nil)
   nil nil))
 (valid_index_rec_offset 0
  (valid_index_rec_offset-1 nil 3746368120
   ("" (induct "expr")
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (skeep*)
      (("4" (expand "offset_rec" 1)
        (("4" (expand "valid_index_rec" 1)
          (("4" (prop)
            (("1" (skeep)
              (("1" (expand "subterm" -2)
                (("1" (prop)
                  (("1" (inst -3 "m" "n")
                    (("1" (expand "valid_index_rec" -3)
                      (("1" (flatten)
                        (("1" (hide -4)
                          (("1" (prop)
                            (("1" (inst -1 "i" "expr")
                              (("1" (assert) nil nil)) nil)
                             ("2" (skeep)
                              (("2"
                                (expand "subterm" -3)
                                (("2"
                                  (inst -3 "i!1" "expr!1")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst -4 "m" "n")
                    (("2" (expand "valid_index_rec" -4)
                      (("2" (flatten)
                        (("2" (hide -5 -3)
                          (("2" (prop)
                            (("1" (inst -1 "i" "expr")
                              (("1" (assert) nil nil)) nil)
                             ("2" (skeep)
                              (("2"
                                (inst -3 "i!1" "expr!1")
                                (("2"
                                  (expand "subterm" -3)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep)
              (("2" (expand "subterm" -2)
                (("2" (prop)
                  (("1" (inst -3 "m" "n")
                    (("1" (expand "valid_index_rec" -3)
                      (("1" (flatten)
                        (("1" (hide -3 -5)
                          (("1" (prop)
                            (("1" (inst -1 "i" "expr")
                              (("1" (assert) nil nil)) nil)
                             ("2" (skeep)
                              (("2"
                                (inst -3 "i!1" "expr!1")
                                (("2"
                                  (expand "subterm" -3)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst -4 "m" "n")
                    (("2" (expand "valid_index_rec" -4)
                      (("2" (flatten)
                        (("2" (hide -3 -4)
                          (("2" (prop)
                            (("1" (inst -1 "i" "expr")
                              (("1" (assert) nil nil)) nil)
                             ("2" (skeep)
                              (("2"
                                (inst -3 "i!1" "expr!1")
                                (("2"
                                  (expand "subterm" -3)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep*)
      (("5" (expand "offset_rec" 1)
        (("5" (expand "valid_index_rec" 1)
          (("5" (prop)
            (("1" (skeep)
              (("1" (expand "subterm" -2)
                (("1" (prop)
                  (("1" (decompose-equality)
                    (("1" (inst -3 "rec1_var" "_")
                      (("1" (inst -3 "rec2_var")
                        (("1" (expand "subterm" -3)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst -3 "m" "n")
                    (("2" (expand "valid_index_rec")
                      (("2" (flatten)
                        (("2" (hide -4)
                          (("2" (prop)
                            (("1" (inst -1 "i" "expr")
                              (("1" (assert) nil nil)) nil)
                             ("2" (skeep)
                              (("2"
                                (inst -3 "i!1" "expr!1")
                                (("2"
                                  (expand "subterm" -3)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep)
              (("2" (expand "subterm" -2)
                (("2" (prop)
                  (("1" (decompose-equality)
                    (("1" (inst -3 "i+n" "offset_rec(n)(rec2_var)")
                      (("1" (expand "subterm") (("1" (assert) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst -3 "m" "n")
                    (("2" (expand "valid_index_rec")
                      (("2" (flatten)
                        (("2" (hide -3)
                          (("2" (prop)
                            (("1" (inst -1 "i" "expr")
                              (("1" (assert) nil nil)) nil)
                             ("2" (skeep)
                              (("2"
                                (inst -3 "i!1" "expr!1")
                                (("2"
                                  (expand "subterm" -3)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skeep*)
      (("6" (expand "offset_rec" 1)
        (("6" (expand "valid_index_rec" 1)
          (("6" (prop)
            (("1" (skeep)
              (("1" (expand "subterm" -2)
                (("1" (prop)
                  (("1" (inst -3 "m" "n")
                    (("1" (expand "valid_index_rec" -3)
                      (("1" (flatten)
                        (("1" (hide -4 -5 -6)
                          (("1" (prop)
                            (("1" (inst -1 "i" "expr")
                              (("1" (assert) nil nil)) nil)
                             ("2" (skeep)
                              (("2"
                                (inst -3 "i!1" "expr!1")
                                (("2"
                                  (expand "subterm" -3)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst -4 "m" "n")
                    (("2" (expand "valid_index_rec" -4)
                      (("2" (flatten)
                        (("2" (hide -3 -5 -6)
                          (("2" (prop)
                            (("1" (inst -1 "i" "expr")
                              (("1" (assert) nil nil)) nil)
                             ("2" (skeep)
                              (("2"
                                (inst -3 "i!1" "expr!1")
                                (("2"
                                  (expand "subterm" -3)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (inst -5 "m" "n")
                    (("3" (expand "valid_index_rec" -5)
                      (("3" (flatten)
                        (("3" (hide -3 -4 -6)
                          (("3" (prop)
                            (("1" (inst -1 "i" "expr")
                              (("1" (assert) nil nil)) nil)
                             ("2" (skeep)
                              (("2"
                                (inst -3 "i!1" "expr!1")
                                (("2"
                                  (expand "subterm" -3)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep)
              (("2" (expand "subterm" -2)
                (("2" (prop)
                  (("1" (inst -3 "m" "n")
                    (("1" (expand "valid_index_rec" -3)
                      (("1" (flatten)
                        (("1" (hide -3 -5 -6)
                          (("1" (prop)
                            (("1" (inst -1 "i" "expr")
                              (("1" (assert) nil nil)) nil)
                             ("2" (skeep)
                              (("2"
                                (inst -3 "i!1" "expr!1")
                                (("2"
                                  (expand "subterm" -3)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst -4 "m" "n")
                    (("2" (expand "valid_index_rec" -4)
                      (("2" (flatten)
                        (("2" (hide -3 -4 -6)
                          (("2" (prop)
                            (("1" (inst -1 "i" "expr")
                              (("1" (assert) nil nil)) nil)
                             ("2" (skeep)
                              (("2"
                                (inst -3 "i!1" "expr!1")
                                (("2"
                                  (expand "subterm" -3)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (inst -5 "m" "n")
                    (("3" (expand "valid_index_rec" -5)
                      (("3" (flatten)
                        (("3" (prop)
                          (("1" (inst -1 "i" "expr")
                            (("1" (assert) nil nil)) nil)
                           ("2" (skeep)
                            (("2" (inst -3 "i!1" "expr!1")
                              (("2"
                                (expand "subterm" -3)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((get_arg shared-adt-accessor-decl
     "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt
     nil)
    (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (rec adt-constructor-decl "[[nat, PVS0Expr] -> (rec?)]"
     PVS0Expr_adt nil)
    (get_from_list adt-accessor-decl "[(rec?) -> nat]" PVS0Expr_adt
     nil)
    (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" PVS0Expr_adt nil)
    (PVS0Expr_induction formula-decl nil PVS0Expr_adt nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (offset_rec def-decl "PVS0Expr" pvs0_lang nil)
    (valid_index_rec const-decl "bool" pvs0_lang nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (add_rec_list_aux2_TCC1 0
  (add_rec_list_aux2_TCC1-1 nil 3746368186 ("" (grind) nil nil)
   ((append def-decl "list[T]" list_props nil)) nil))
 (add_rec_list_aux2 0
  (add_rec_list_aux2-1 nil 3746368277
   ("" (measure-induct+ "lex2(k,sizepvs0(expr))" ("expr" "k"))
    (("1" (skeep*)
      (("1" (expand "eval_expr" 1)
        (("1" (lift-if)
          (("1" (prop)
            (("1" (beta)
              (("1" (inst -2 "get_arg(x!1)" "x!2")
                (("1" (inst -2 "false_val" "lexpr1" "lexpr2")
                  (("1" (prop)
                    (("1" (inst -1 "f1" "f2")
                      (("1" (inst -1 "i")
                        (("1" (assert)
                          (("1" (replace -1 :dir rl)
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide 2) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (typepred "lexpr1")
                      (("2" (replace -2)
                        (("2" (expand "valid_index_rec" -3)
                          (("2" (expand "valid_index_rec" 1)
                            (("2" (skeep)
                              (("2"
                                (inst -3 "i!1" "expr")
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (inst-cp -2 "get_arg1(x!1)" "x!2")
                (("2" (inst -2 "get_arg2(x!1)" "x!2")
                  (("2" (inst -2 "false_val" "lexpr1" "lexpr2")
                    (("1" (prop)
                      (("1" (inst -3 "false_val" "lexpr1" "lexpr2")
                        (("1" (prop)
                          (("1" (inst?)
                            (("1" (inst?)
                              (("1"
                                (assert)
                                (("1"
                                  (replace -1 :dir rl)
                                  (("1"
                                    (replace -2 :dir rl)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil)
                         ("2" (hide -1 2)
                          (("2" (typepred "lexpr1")
                            (("2" (replace -2)
                              (("2"
                                (expand "valid_index_rec" -3)
                                (("2"
                                  (expand "valid_index_rec" 1)
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (inst -3 "i!1" "expr")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (hide 2 -2)
                      (("2" (typepred "lexpr1")
                        (("2" (replace -2)
                          (("2" (expand "valid_index_rec" -3)
                            (("2" (expand "valid_index_rec" 1)
                              (("2"
                                (skeep)
                                (("2"
                                  (inst -3 "i!1" "expr")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (assert)
              (("3" (inst-cp -2 "get_cond(x!1)" "x!2")
                (("3" (inst-cp -2 "get_if(x!1)" "x!2")
                  (("3" (inst -2 "get_else(x!1)" "x!2")
                    (("3" (inst -2 "false_val" "lexpr1" "lexpr2")
                      (("1" (prop)
                        (("1" (inst -3 "false_val" "lexpr1" "lexpr2")
                          (("1" (prop)
                            (("1"
                              (inst -4 "false_val" "lexpr1" "lexpr2")
                              (("1"
                                (prop)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (inst?)
                                    (("1"
                                      (inst?)
                                      (("1"
                                        (replace -1 :dir rl)
                                        (("1"
                                          (replace -2 :dir rl)
                                          (("1"
                                            (replace -3 :dir rl)
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil)
                               ("2"
                                (hide -1 -2 2)
                                (("2"
                                  (typepred "lexpr1")
                                  (("2"
                                    (replace -2)
                                    (("2"
                                      (expand "valid_index_rec" -3)
                                      (("2"
                                        (expand "valid_index_rec" 1)
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (inst -3 "i!1" "expr")
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("2" (hide -1 -3 2)
                            (("2" (typepred "lexpr1")
                              (("2"
                                (replace -2)
                                (("2"
                                  (expand "valid_index_rec" -3)
                                  (("2"
                                    (expand "valid_index_rec" 1)
                                    (("2"
                                      (skeep)
                                      (("2"
                                        (inst -3 "i!1" "expr")
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (hide -2 -3 2)
                        (("2" (typepred "lexpr1")
                          (("2" (replace -2)
                            (("2" (expand "valid_index_rec" -3)
                              (("2"
                                (expand "valid_index_rec" 1)
                                (("2"
                                  (skeep)
                                  (("2"
                                    (inst -3 "i!1" "expr")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("4" (assert)
              (("4" (typepred "lexpr1")
                (("4" (expand "valid_index_rec" -3)
                  (("4" (inst -3 "get_from_list(x!1)" "get_arg(x!1)")
                    (("4" (expand "subterm")
                      (("4" (case "rec?(x!1)")
                        (("1" (prop)
                          (("1" (rewrite "length_append")
                            (("1" (assert)
                              (("1"
                                (rewrite "nth_append")
                                (("1"
                                  (inst-cp -5 "get_arg(x!1)" "x!2")
                                  (("1"
                                    (inst
                                     -5
                                     "nth(lexpr1, get_from_list(x!1))"
                                     "x!2-1")
                                    (("1"
                                      (inst
                                       -5
                                       "false_val"
                                       "lexpr1"
                                       "lexpr2")
                                      (("1"
                                        (prop)
                                        (("1"
                                          (inst
                                           -6
                                           "false_val"
                                           "lexpr1"
                                           "lexpr2")
                                          (("1"
                                            (prop)
                                            (("1"
                                              (inst -1 "f1" "f2")
                                              (("1"
                                                (inst -1 "i")
                                                (("1"
                                                  (inst -2 "f1" "f2")
                                                  (("1"
                                                    (inst
                                                     -2
                                                     "val(eval_expr(f1, f2, false_val, lexpr1)
                                                                        (x!2, get_arg(x!1), i))")
                                                    (("1"
                                                      (replace
                                                       -1
                                                       :dir
                                                       rl)
                                                      (("1"
                                                        (replace
                                                         -2
                                                         :dir
                                                         rl)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (grind) nil nil))
                                            nil)
                                           ("2"
                                            (hide -1 3)
                                            (("2"
                                              (typepred "lexpr1")
                                              (("2"
                                                (replace -2)
                                                (("2"
                                                  (expand
                                                   "valid_index_rec"
                                                   -3)
                                                  (("2"
                                                    (expand
                                                     "valid_index_rec"
                                                     1)
                                                    (("2"
                                                      (skeep)
                                                      (("2"
                                                        (inst
                                                         -3
                                                         "i!1"
                                                         "expr")
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil)
                                       ("2"
                                        (hide -5 3)
                                        (("2"
                                          (replace -4)
                                          (("2"
                                            (typepred "lexpr1")
                                            (("2"
                                              (assert)
                                              (("2" (inst?) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (decompose-equality) nil nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)
     ("5" (grind) nil nil) ("6" (grind) nil nil) ("7" (grind) nil nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (None adt-constructor-decl "(none?)" Maybe "structures/")
    (none? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (get_op shared-adt-accessor-decl
     "[{x: PVS0Expr | op1?(x) OR op2?(x)} -> nat]" PVS0Expr_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (Some adt-constructor-decl "[T -> (some?)]" Maybe "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (i skolem-const-decl "Val" pvs0_lang nil)
    (x!2 skolem-const-decl "nat" pvs0_lang nil)
    (false_val skolem-const-decl "Val" pvs0_lang nil)
    (f2 skolem-const-decl "EvalOp2[Val]" pvs0_lang nil)
    (f1 skolem-const-decl "EvalOp1[Val]" pvs0_lang nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nth_append formula-decl nil more_list_props "structures/")
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil list_props nil)
    (PVS0Expr_rec_extensionality formula-decl nil PVS0Expr_adt nil)
    (get_from_list adt-accessor-decl "[(rec?) -> nat]" PVS0Expr_adt
     nil)
    (get_if adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt nil)
    (get_else adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt
     nil)
    (get_cond adt-accessor-decl "[(ite?) -> PVS0Expr]" PVS0Expr_adt
     nil)
    (get_arg2 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt
     nil)
    (eval_op2 const-decl "Val" pvs0_expr nil)
    (rec adt-constructor-decl "[[nat, PVS0Expr] -> (rec?)]"
     PVS0Expr_adt nil)
    (cnst? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt
     nil)
    (cnst adt-constructor-decl "[T -> (cnst?)]" PVS0Expr_adt nil)
    (FALSE const-decl "bool" booleans nil)
    (vr? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (vr adt-constructor-decl "(vr?)" PVS0Expr_adt nil)
    (op1 adt-constructor-decl "[[nat, PVS0Expr] -> (op1?)]"
     PVS0Expr_adt nil)
    (op2 adt-constructor-decl "[[nat, PVS0Expr, PVS0Expr] -> (op2?)]"
     PVS0Expr_adt nil)
    (ite? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (ite adt-constructor-decl
     "[[PVS0Expr, PVS0Expr, PVS0Expr] -> (ite?)]" PVS0Expr_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (op2? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (get_arg1 adt-accessor-decl "[(op2?) -> PVS0Expr]" PVS0Expr_adt
     nil)
    (lexpr1 skolem-const-decl "{lexpr1: lPVS0Expr |
         (FORALL (j: below(length(lexpr1))):
            valid_index_rec(nth(lexpr1, j), length(lexpr1)))
          AND valid_index_rec(x!1, length(lexpr1))}" pvs0_lang nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[PVS0Expr -> nat]" PVS0Expr_adt nil)
    (eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}"
     pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          i > 0 AND
           (FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env))}"
     pvs0_lang nil)
    (eval_op1 const-decl "Val" pvs0_expr nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" PVS0Expr_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (get_arg shared-adt-accessor-decl
     "[{x: PVS0Expr | op1?(x) OR rec?(x)} -> PVS0Expr]" PVS0Expr_adt
     nil)
    (rec? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (x!1 skolem-const-decl "PVS0Expr[Val]" pvs0_lang nil)
    (op1? adt-recognizer-decl "[PVS0Expr -> boolean]" PVS0Expr_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_expr nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Maybe type-decl nil Maybe "structures/")
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (valid_index_rec const-decl "bool" pvs0_lang nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (well_founded_le formula-decl nil ordinals nil)
    (< def-decl "bool" ordinals nil)
    (sizepvs0 const-decl "[PVS0Expr -> nat]" pvs0_expr nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   nil))
 (add_rec_list 0
  (add_rec_list-1 nil 3746369761
   ("" (skeep*)
    (("" (prop)
      (("1" (use "semantic_rel_eval_expr")
        (("1" (assert)
          (("1" (skeep)
            (("1" (use "add_rec_list_aux")
              (("1" (lemma "eval_expr_semantic_rel")
                (("1"
                  (inst -1 "(f1, f2, false_val,
    append(lexpr2,
                                       map(offset_rec(length(lexpr2)))(lexpr1)))"
                   "i" "offset_rec(length(lexpr2))(expr)"
                   "val(eval_expr(f1, f2, false_val, append(lexpr2,
                                       map(offset_rec(length(lexpr2)))(lexpr1)))(n, offset_rec(length(lexpr2))(expr), i))"
                   "n")
                  (("1" (assert) (("1" (assert) nil nil)) nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (use "semantic_rel_eval_expr")
        (("2" (assert)
          (("2" (skeep)
            (("2" (use "add_rec_list_aux")
              (("2" (lemma "eval_expr_semantic_rel")
                (("2"
                  (inst -1 "(f1, f2, false_val, lexpr1)" "i" "expr"
                   "o1" "n")
                  (("2" (assert) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}"
     pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          i > 0 AND
           (FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env))}"
     pvs0_lang nil)
    (add_rec_list_aux formula-decl nil pvs0_lang nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (i skolem-const-decl "Val" pvs0_lang nil)
    (expr skolem-const-decl "PVS0Expr[Val]" pvs0_lang nil)
    (n skolem-const-decl "nat" pvs0_lang nil)
    (lexpr1 skolem-const-decl "lPVS0Expr[Val]" pvs0_lang nil)
    (length def-decl "nat" list_props nil)
    (offset_rec def-decl "PVS0Expr" pvs0_lang nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (lexpr2 skolem-const-decl "lPVS0Expr[Val]" pvs0_lang nil)
    (append def-decl "list[T]" list_props nil)
    (false_val skolem-const-decl "Val" pvs0_lang nil)
    (f2 skolem-const-decl "EvalOp2[Val]" pvs0_lang nil)
    (f1 skolem-const-decl "EvalOp1[Val]" pvs0_lang nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_expr nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (eval_expr_semantic_rel formula-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (semantic_rel_eval_expr formula-decl nil pvs0_expr nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (add_rec_list2 0
  (add_rec_list2-1 nil 3746372619
   ("" (skeep*)
    (("" (prop)
      (("1" (use "semantic_rel_eval_expr")
        (("1" (assert)
          (("1" (skeep)
            (("1" (use "add_rec_list_aux2")
              (("1" (lemma "eval_expr_semantic_rel")
                (("1"
                  (inst -1 "(f1,f2,false_val,append(lexpr1, lexpr2))"
                   "i" "expr"
                   "val(eval_expr(f1, f2, false_val, append(lexpr1, lexpr2))(n, expr, i))"
                   "n")
                  (("1" (assert) (("1" (assert) nil nil)) nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (use "semantic_rel_eval_expr")
        (("2" (assert)
          (("2" (skeep)
            (("2" (use "add_rec_list_aux2")
              (("2" (lemma "eval_expr_semantic_rel")
                (("2"
                  (inst -1 "(f1,f2,false_val,lexpr1)" "i" "expr"
                   "val(eval_expr(f1, f2, false_val, lexpr1)(n, expr, i))"
                   "n")
                  (("1" (assert) (("1" (assert) nil nil)) nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((eval_expr_semantic_rel_j rec-application-judgement
     "{myv: Maybe[Val] |
         some?(myv) IMPLIES semantic_rel_expr(pvs0)(expr, env, val(myv))}"
     pvs0_lang nil)
    (eval_expr_ge_n_j rec-application-judgement "{myv: Maybe[Val] |
         some?(myv) IMPLIES
          i > 0 AND
           (FORALL (m: upfrom(i)): myv = eval_expr(pvs0)(m, expr, env))}"
     pvs0_lang nil)
    (add_rec_list_aux2 formula-decl nil pvs0_lang nil)
    (i skolem-const-decl "Val" pvs0_lang nil)
    (n skolem-const-decl "nat" pvs0_lang nil)
    (lexpr2 skolem-const-decl "lPVS0Expr[Val]" pvs0_lang nil)
    (lexpr1 skolem-const-decl "{lexpr1: lPVS0Expr |
         (FORALL (j: below(length(lexpr1))):
            valid_index_rec(nth(lexpr1, j), length(lexpr1)))
          AND valid_index_rec(expr, length(lexpr1))}" pvs0_lang nil)
    (expr skolem-const-decl "PVS0Expr[Val]" pvs0_lang nil)
    (append def-decl "list[T]" list_props nil)
    (false_val skolem-const-decl "Val" pvs0_lang nil)
    (f2 skolem-const-decl "EvalOp2[Val]" pvs0_lang nil)
    (f1 skolem-const-decl "EvalOp1[Val]" pvs0_lang nil)
    (eval_expr def-decl "Maybe[Val]" pvs0_expr nil)
    (some? adt-recognizer-decl "[Maybe -> boolean]" Maybe
     "structures/")
    (Maybe type-decl nil Maybe "structures/")
    (val adt-accessor-decl "[(some?) -> T]" Maybe "structures/")
    (eval_expr_semantic_rel formula-decl nil pvs0_expr nil)
    (list type-decl nil list_adt nil)
    (EvalOp1 type-eq-decl nil pvs0_expr nil)
    (EvalOp2 type-eq-decl nil pvs0_expr nil)
    (PVS0Expr type-decl nil PVS0Expr_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (lPVS0Expr type-eq-decl nil pvs0_expr nil)
    (PVS0 type-eq-decl nil pvs0_expr nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (valid_index_rec const-decl "bool" pvs0_lang nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (semantic_rel_eval_expr formula-decl nil pvs0_expr nil)
    (Val formal-nonempty-type-decl nil pvs0_lang nil)
    (n skolem-const-decl "nat" pvs0_lang nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)))

